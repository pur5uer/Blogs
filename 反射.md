# 反射

> 反射：运行时的类信息

## 概述

Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构。所以，我们形象地称之为：反射。

### Java反射的优点和缺点

- 优点：可以实现动态创建对象和编译，体现了很大的灵活性。



- 缺点：对性能有影响。使用反射基本上是一种解释操作，这类操作总是慢于直接执行相同的操作。

## Class类

通过反射可以得到的信息：某个类的属性、方法和构造器、实现的接口。对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定某个结构（class/interface/enum/annotation/primitive type/void/[]）的有关信息。

- Class本身也是一个类
- Class对象只能由系统创建
- 一个加载的类在JVM中只会有一个Class实例
- 一个Class对象对应的是一个加载到JVM中的一个.class文件
- 每个类的实例都会记得自己是由哪个Class实例所生成
- 通过Class可以完整地得到一个类中的所有被加载的结构
- Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象

### Class类的常用方法

| 方法名                                                    | 说明                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| static Class forName(String name)                         | 返回指定类名name的Class对象                                  |
| Object newInstance()                                      | 调用缺省构造函数，返回Class对象的一个实例                    |
| getName()                                                 | 返回此Class对象所表示的实体（类，接口，数组类或void）的名称  |
| Class getSuperClass()                                     | 返回当前Class对象的父类的Class对象                           |
| Class[] getInterfaces()                                   | 获取当前Class对象所表示的类或接口实现的接口                  |
| ClassLoader getClassLoader()                              | 返回该类的类加载器                                           |
| Constructor[] getConstructors()                           | 返回一个包含某些Constructor对象的数组，这些对象反映声明为此Class对象所表示的类的指定公共构造方法 |
| Method getMethod(String name, Class<?>... parameterTypes) | 返回一个Method对象，它反映此Class对象所表示的接口或类的指定公共成员方法 |
| Field[] getDeclaredFields()                               | 返回Field对象的一个数组，这些对象反映此Class对象所表示的类或接口所声明的所有字段。 |

### 获取Class类的实例

1. 已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高

   Class clazz = Person.class;

2. 已知某个类的实例，调用该实例的getClass()方法获取Class对象

   Class clazz = person.getClass();

3. 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取

   Class clazz = Class.forName("包名.类名");

4. 内置基本数据类型可以直接用类名.Type
5. 利用ClassLoader

### 所有类型的Class对象

- class
- interface
- []
- enum
- annotation
- primitive type
- void

## 类加载内存分析

待学习